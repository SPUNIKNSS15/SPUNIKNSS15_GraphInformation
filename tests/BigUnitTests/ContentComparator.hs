module Main
where
 
import Text.XML.HXT.Core
import System.IO
import System.Environment
import System.Console.GetOpt
import System.Exit
import Data.List

main :: IO ()
main
    = do
      argv <- getArgs
      (oldArg, newArg) <- cmdlineOpts argv
      oldFile <- readFile oldArg
      newFile <- readFile newArg
      putStrLn $ outputCollector oldFile newFile 


cmdlineOpts :: [String] -> IO (String, String)
cmdlineOpts argv
    = return (argv!!0, argv!!1)


--outputCollector :: String -> String -> String
--outputCollector old new =  "Length: "++(show $ length $ getSimpleNames old) ++"\n"
--                            ++ (show $ getSimpleNames old) ++ "\n"
--                            ++ (show $ nceTriples old) ++ "\n"
--                            ++ (show $ matchSimples old new)
                         
outputCollector :: String -> String -> String
outputCollector old new =  "#simples in fst arg: " ++ (show $ length $ getSimpleNames old) ++ "\n"
                        ++ "#simples in snd arg: " ++ (show $ length $ getSimpleNames new) ++ "\n"
                        ++ "#matches fst \\cap snd: " ++ (show $ length $ matchSimples old new) ++ "\n" 
			++ "unmatched old simples: " ++ (show $ unmatchedSimples (map fst (matchSimples old new)) $ getSimpleNames old) ++ "\n"
			++ "unmatched new simples: " ++ (show $ unmatchedSimples (map snd (matchSimples old new)) $ getSimpleNames new) ++ "\n" 


-- nceTriples old Takes an XML document, parses it and returns a tree containing all <simple>s
getSimples :: ArrowXml a => a String XmlTree
getSimples  =  xreadDoc >>> getChildren >>> hasName "simple" 

-- Takes an XML document, parses it and returns a list of all <simple> names
getSimpleNames :: String -> [String]
getSimpleNames x = filter (/= []) $ runLA (getSimples >>> getAttrValue "name") x


-- Takes a name string and an XML document, parses it and returns an edge
-- string containing the edges of the specified <simple>. 
getEdgesByName :: String -> String -> String
getEdgesByName name file = concat $ runLA (getSimples >>> hasAttrValue "name" (== name) >>> getEdges) file
    where
        getEdges = getChildren >>> hasName "edges" >>> getChildren >>> getText

-- Takes a name string and a XML document, parses it and returns a string
-- containing the node count of the specified <simple>.
getNodesByName :: String -> String -> String
getNodesByName name file = concat $ runLA (getSimples >>> hasAttrValue "name" (== name) >>> getNodes) file 
    where
        getNodes = getChildren >>> hasName "nodes" >>> getAttrValue "count"


-- Takes a XML Document, parses it and returns a [(String, String, String)],
-- where the triples contain names, node counts and edge strings of all found
-- <simple> graphs. 
nceTriples :: String -> [(String, String, String)]
nceTriples x = builder $ getSimpleNames x
	where
		builder [] = []
		builder (y:ys) = (y, getNodesByName y x, getEdgesByName y x) : builder ys


-- Takes two XML documents, parses them and returns a list of matching <simple>
-- graphs, where matching means that both the node counts and the strings
-- representing the edges are equal, whereas the latter equality is the usual
-- equality on lists. 
matchSimples :: String -> String -> [(String, String)]
matchSimples old new = match (nceTriples old) (nceTriples new)
    where
        match  _ [] = []
        match []  _ = []
        match ((xn,xc,xe):xs) ys = if (tfilter xc xe ys) /= []  && length (tfilter xc xe ys) == 1
                                then (xn, fst_3 $ (tfilter xc xe ys)!!0 ) : match xs (tnfilter xc xe ys)
                                else match xs ys                   
        tfilter xc xe ys = filter (\z -> (((==xc).snd_3) z) && (((==xe).trd_3) z)) ys 
	tnfilter xc xe ys = filter (\z -> (((/=xc).snd_3) z) || (((/=xe).trd_3) z)) ys


-- Takes a list of matched <simples>, propably generated by 
-- map fst (matchSimples ...) returns a list of <simples>, which are in the
-- first, but not in the second argument.
unmatchedSimples :: [String] -> [String] -> [String]
unmatchedSimples x y = filter (not.(flip elem x)) y



fst_3  (x,_,_) = x
snd_3  (_,x,_) = x
trd_3  (_,_,x) = x


